DB：数据库，存储数据的集合

DBMS：数据库管理系统，多个DB + 管理程序

DBS：数据库系统，更大的概念，包含DB、DBMS、DBA

RDBMS：关系型数据库，SQL就是关系型数据库的查询语言

NoSQL泛指非关系型数据库，如键值型Redis、文档型MongoDB、搜索引擎ES Splunk Solr、列存储、图数据库等

搜索引擎的核心原理是倒排索引，用来实现全文检索

列数据库：降低系统IO，适合分布式文件系统，但功能相对有限

ER Diagram：实体关系图，包含实体、属性、关系，一对一、一对多、多对多

### SQL

SQL：Structural Query Lanuage

SQL按照功能划分为四个部分

* DDL：数据定义语言，创建、删除、修改数据库或表结构
* DML：数据操作语言，如插入、删除、修改表记录
* DCL：数据控制语言，如控制访问权限和安全级别
* DQL：数据查询语言

规范：

* 表名、表别名、字段名、字段别名使用小写，字段名推荐下划线
* SQL保留字、函数、绑定变量等使用大写

### DDL

没有事务不需要COMMIT，CREATE  DROP  ALTER

CREATE DATABASE play [ IF NOT EXISTS ] play DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_general_ci

ALTER TABLE player ADD （age int）

ALTER TABLE player MODIFY （age  bigint）

ALTER TABLE player DROP COLUMN age

ALTER TABLE player RENAME COLUMN age to play_age

表设计原则：简单可复用，简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率

- 键约束
    - 主键约束：NOT NULL + UNIQUE，一张表主键只能有一个，可以是一个字段，也可以是复合字段，会创建主键索引
    - 外键约束：确定表与表之间引用的完整性，一张表中的外键对应另一张表的逐渐，外键可以重复，可以为空
- 字段约束
    - UNIQUE约束：同时会创建唯一索引（UNIQUE INDEX）
    - NOT NULL约束
    - DEFAULT约束 
    - CHECK约束：CHECK（age >= 18 and age <= 70）

主键、外键、索引关系

varchar(n)是n个字节，非Unicode字符。英文字母占1个字节，中文占2个字节

nvarchar(n)是n个字符，Unicode字符。英文字母或者中文都是占用2个字节

### DQL

SELECT [distinct] ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...

FROM > WHERE > GROUP BY > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT

SELECT可以查询列、常数、函数、子查询

ORDER BY可以使用不在SELECT中选择的字段排序   ASC   DESC

AS取别名

对于全表查询的语句，在知道返回结果只会有一个时使用 limit 1可以提升查询效率 

表JOIN

1. 通过 CROSS JOIN 求笛卡尔积
2. 通过 ON 进行筛选
3. 如果我们使用的是左连接、右链接或者全连接，还会涉及到添加外部行

> 作者回复: 关于COUNT(\*)的效率是一个很好的问题，欢迎探讨：
> 在MySQL InnoDB存储引擎中，COUNT(\*)和COUNT(1)都是对的所有结果进行的COUNT。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计。如果没有WHERE子句，则是对数据表的数据行数进行统计。
> 因此COUNT(\*)和COUNT(1)本质上没有区别，执行的复杂度都是O(N)，也就是采用全表扫描，进行循环+计数的方式进行统计。
> 如果是MySQL MyISAM存储引擎，统计数据表的行数只需要O(1)复杂度，这是因为每张MyISAM的数据表都有一个meta信息有存储了row_count值。而一致性由表级锁来保证。而InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，只维护一个row_count变量。因此就需要采用扫描全表，进行循环+计数的方式来完成统计。
> 需要注意的是，在实际执行中COUNT(\*)和COUNT(1)执行时间可能略有差别，不过你还是可以把这两个在执行效率上看成是相等的。
>
> 另外在InnoDB引擎中，如果是采用COUNT(\*)和COUNT(1)来统计数据行数，要尽量采用二级索引。
> 因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。
> 对于查找具体的行来说，采用主键索引效率更高。而对于COUNT(\*)和COUNT(1)这种，不需要查找具体的行，只是统计行数来说，系统会自动采用占用空间更小的二级索引来进行统计。
> 如果有多个二级索引的时候，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。
>
> 优化总结：
> 1、一般情况下：COUNT(\*) = COUNT(1) > COUNT(字段)
> 所以尽量使用COUNT(\*)，当然如果你要统计的是就是某个字段的非空数据行数，那另当别论。毕竟执行效率比较的前提是要结果一样才行。
> 2、如果要统计COUNT(\*)，尽量在数据表上建立二级索引，系统会自动采用key_len小的二级索引进行扫描，这样当我们使用SELECT COUNT(*)的时候效率就会提升，有时候提升几倍甚至更高都是有可能的。
>
> 作者回复: 这是一个很好的问题，关于ORDER BY字段是否增加索引：
> 在MySQL中，支持两种排序方式：FileSort和Index排序。Index排序的效率更高，
> Index排序：索引可以保证数据的有序性，因此不需要再进行排序。
> FileSort排序：一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序，效率较低。
>
> 所以使用ORDER BY子句时，应该尽量使用Index排序，避免使用FileSort排序。
> 当然具体优化器是否采用索引进行排序，你可以使用explain来进行执行计划的查看。
> 优化建议：
> 1、SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中避免全表扫描，ORDER BY子句避免使用FileSort排序。
> 当然，某些情况下全表扫描，或者FileSort排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
> 一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。
> 2、尽量Using Index完成ORDER BY排序。
> 如果WHERE和ORDER BY相同列就使用单索引列；如果不同使用联合索引。
> 3、无法Using Index时，对FileSort方式进行调优。

#### SQL函数

算术函数

字符串函数

日期函数

转换函数

聚集函数：COUNT MAX MIN AVG SUM，MAX、MIN、AVG会忽略NULL，COUNT(*)只会统计行数，COUNT(字段)会过滤NULL

函数会导致不走索引，不要在WHERE中使用函数

#### WHERE过滤

and、or、not、between and、like、is null、in、算术比较

% ：零个或多个字符   _ ：一个字符 

like以%开头，即使有索引也会进行全表扫描，不以%开头且有索引，不会进行全表扫描

#### GROUP BY 和 HAVING

GROUP BY用于分组

HAVING用于分组过滤，WHERE用于数据行过滤

#### 子查询

关联子查询：循环执行

非关联子查询：只执行一次

EXISTS：子查询是否存在数据

IN：是否在集合中

ANY：和比较操作符一起用

ALL：和比较操作符一起用

在建立索引的情况下，EXISTS和IN效率

SELECT * FROM a WHERE x IN (SELECT x FROM b)

SELECT * FROM a WHERE EXISTS (SELECT x FROM b WHERE a.x = b.x)

若A表比B表大，使用IN；若A表比B表小，使用EXISTS

#### 表连接

##### 内连接

等值连接：将两张表先笛卡尔积，再进行等值比较

自然连接：将两个表中名称相同的字段进行等值比较

等值连接       SELECT * FROM a,b WHERE a.id = b.id

等值连接       SELECT * FROM a JOIN b ON a.id = b.id

自然连接       SELECT * FROM a NATURAL JOIN b

USING连接   SELECT * FROM a JOIN b USING(id)

非等值连接：用等号判断连接的就是等值连接，其余的判断条件就是非等值连接

自连接：同一张表连接

##### 外连接

左外连接：左边的表位主表，显示其全部行

SELECT * FROM a LEFT JOIN b ON a.id = b.id

右外连接：右边的表为主表，显示其全部行

SELECT * FROM a RIGHT JOIN b ON a.id = b.id

全外连接： 两边的表都显示其全部行

SELECT * FROM a FULL JOIN b ON a.id = b.id

Mysql不支持全外连接

##### 交叉连接 / 笛卡尔积

X表每一行和Y表每一行两两相连，结果集的数量为X * Y

SQL92    SELECT * FROM a,b

SQL99    SELECT * FROM a CROSS JOIN b

### DML

INSERT

UPDATE

DELETE

### DCL

### 视图

<img src="../.image/image-20201203195844916.png" alt="image-20201203195844916" style="zoom:25%;" />

视图：虚拟表，对select语句进行了封装，相当于一张表或多张表的结果集

CREATE VIEW  viewname AS SELECT ...

ALTER VIEW viewname AS SELECT ...

DROP VIEW viewname

### 事务

InnoDB支持事务，MylSAM不支持事务，MySQL5.5后默认InnoDB

Atomic：原子性，不可分割，一次数据处理基本单元

Consistency：一致性，事务提交或回滚，不影响数据的完整性约束

Isolation：隔离性，每个事务是独立的，在一个事务提交前，对其他事务不可见

DUrability：持久性，事务提交后对数据的修改是持久性的，通过事务日志保证，包括回滚日志和重做日志

显示事务和隐式事务，MySQL默认隐式事务，自动提交，set autocommit = 0关闭

START TRANSACTION或BEGIN：开启事务

COMMIT：提交事务

ROLLBACK或ROLLBACK TO [SAVEPOINT]：回滚事务到某个保存点，一个事务可以有多个保存点

RELEASE [SAVEPOINT]：删除某个保存点

SET TRANSACTION：设置事务隔离级别

SET @@completion_type = 

* 0：默认
* 1：提交事务后相当于执行COMMIT AND CHAIN，提交事务之后会开启一个相同隔离级别的事务
* 2：提交事务后相当于执行COMMIT AND RELEASE，自动与服务器断开连接

连续BEGINE会隐式将上一个BEGIN提交事务

如果事务中遇到错误仍COMMIT，会讲事务中执行成功的操作提交

### 事务隔离

事务并发异常

* 脏读：读到了其它事务还没提交的数据
* 不可重复读：对某数据进行读取，发现两次读取的结果不同，因为有其他事务对这个数据进行了修改或删除，重点在UPDATE和DELETE
* 幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，重点在INSERT

事务隔离级别：SHOW VARIABLES LIKE 'transaction_isolation'

|          | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 读未提交 | 允许   | 允许       | 允许   |
| 读已提交 | 不允许 | 允许       | 允许   |
| 可重复读 | 不允许 | 不允许     | 允许   |
| 可串行化 | 不允许 | 不允许     | 不允许 |

### 存储过程

### 游标








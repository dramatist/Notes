### WebMVC

基于Servlet API

* 简化Web开发
* 约定大于配置的契约编程
* 易于测试
* 和IOC、AOP集成
* 灵活的数据校验、格式化、数据绑定
* 本地化、主题
* 支持静态资源
* 支持RESTful

### DispatcherServlet

基于Front Controller模式设计，DispatcherServlet提供了用于请求处理的共享算法，而请求映射、视图解析、异常处理等实际工作由可配置的委托组件执行

* web.xml
    * ContextLoadListener配置Root WebApplicationContext
    * XmlApplicationContext没有配置configLocation时，getDefaultConfigLocations
        1. DispatcherServlet：默认配置文件为/WEB-INF/ServletName-servlet.xml
        2. ContextLoadListener：默认配置文件为/WEB-INF/applicationContext.xml
* WebApplicationInitializer
    * ServletContainerInitializer SPI 加载SpringServletContainerInitializer处理WebApplicationInitializer
    * AbstractAnnotationConfigDispatcherServletInitializer

<img src=".image/image-20210825155537374.png" alt="image-20210825155537374" style="zoom:30%;" />

依赖：默认使用DispatcherServlet.properties中声明的依赖

事件触发九大组件初始化，init ---> initServletBean ---> initWebApplicationContext ---> onRefresh

#### HandlerMapping

根据请求找到Handler及Interceptor，封装为HandlerExecutionChain返回给DispatcherServlet

<img src=".image/image-20210831145752966.png" alt="image-20210831145752966" style="zoom:50%;" />

路径匹配

* 基于去除contextPath和servletMapping前缀的路径寻找Handler

拦截器

过滤器Filter：对Request进行处理，在Servlet处理之前

监听器Listener：实现ServletContextListener，监听容器，随容器的初始化而创建，随容器的销毁而销毁

拦截器Interceptor：对Handler拦截

* HandlerInterceptor
* preHandle顺序调用，返回false时，不会执行接下来的拦截器和Handler
* postHandle逆序调用，所有拦截器返回true时才调用
* afterCompletion逆序调用，只有preHandle返回true时才调用
* 对于@ResponseBody和ResponseEntity，postHandle失效，response已经被写入HandlerAdapter，可以实现ResponseBodyAdvoce并标注@ControllerAdvice解决，也可直接将其注册入RequestMappingHandlerAdapter

#### HandlerAdapter

根据适配器接口对Handler包装后执行

<img src=".image/image-20210831155729549.png" alt="image-20210831155729549" style="zoom:50%;" />

#### HandlerExceptionResolver

Exception处理策略，如映射到Handler或HTML错误页面

在requestMapping阶段或Handler执行抛出异常，异常被放入ExceptionHandlerResolver Chain，返回

* ModelAndView指向错误页面
* 空ModelAndView，表明Exception已被Resolver解决
* null，表明无法处理，交给下一个ExceptionHandlerResolver

@ControllerAdvice、@ExceptionHandler

#### ViewResolver

ViewResolver：提供view name和view之间的映射

View：解决数据传递给特定视图技术之前的准备工作

JSP场景只能通过RequestDispatcher确认是否存在，需要配置InternalResourceViewResolver，且优先级最低

#### MultipartResolver

文件上传

* CommonMultipartResolver，适用于Servlet3.0之前的前版本，依赖common-fileupload
* StandardServletMultipartResolver，适用于Servlet3.0之后的版本，无依赖，但需配置
    * XML：multipart-config
    * Java：registration.setMultipartConfig

#### LocaleResolver

* AcceptHeaderLocaleResolver，默认配置，通过Header的accept-language指定
* LocaleContextResolver
    * CookieLocaleResolver
    * SessionLocaleResolver
    * FixedLocaleResolver

RequestContext.getLocale

#### ThemeResolver

主题管理

#### FlashMapManager

FlashMap用于重定向时参数传递。在重定向之前将要传递的数据写入请求(可以通过ServletRequestAttributes.getRequest()方法获得)的属性OUTPUT_FLASH_MAP_ATTRIBUTE 中，这样在重定向之后的Handler中Spring就会自动将其设置到Model中

在方法参数中增加RedirectAttributes，调用addFlashAttribute

#### ViewNameTranslator

#### 请求处理流程

service ---> processRequest ---> doService ---> doDispatch

* Request Attribute中放入ApplicationContext、localeResolver、themeResolver、themeSource、flashMapper等
* 如果配置了MultipartResolver，并且请求中有Multipart，请求被处理为MultipartHttpServletRequest
* HandlerMapping找到一个合适的Handler处理请求，将Handler和Interceptor封装为HandlerExecutionChain
* HandlerAdapter处理
* ViewResolver解析
* 视图渲染

### 参数绑定

* Model、ModelMap、Map 
    * Map  ---- LinkedHashMap ---- ModelMap
    * ExtendedModelMap extends ModelMap implements Model
    * BindingAwareModelMap extends ExtendedModelMap 
* HttpServletRequest、HttpServletResponse、HttpServletSession
* 基本数据类型及其包装类，String
* POJO实体类
* 自定义参数转换，Converter，针对未提供类型转换的类型
* 数组、集合

返回值

* ModelAndView
* Void
* String，视图名或字符串(@ResponseBody，注意编码)
* 实体类，@ResponseBody + JSON解析器，默认支持Jackson

### Filter

* FormContentFilter
* Forwarded

### RESTful

一个资源定位及操作的风格

互联网中所有东西都是资源，都有唯一的uri

请求方式代表增删改查，URL中只有名词，没有动词

@PathVariable  /user/{id}

@RequestBody

@ResponseBody

### 

